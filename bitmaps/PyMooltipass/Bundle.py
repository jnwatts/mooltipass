#
# Copyright (c) 2014 Darran Hunt (darran [at] hunt dot net dot nz)
# All rights reserved.
#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at src/license_cddl-1.0.txt
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at src/license_cddl-1.0.txt
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
# Portions Copyright 2014 Josh Watts (josh [at] sroz dot net)


#
# Bundle a collection of bitmaps into a flat image with indices that can
# be imported into the SPI flash media region on the mooltipass
#

import os;
import sys;
import md5;
from struct import pack,unpack;

from MediaTypes import *;
from BundleFile import *;

class Bundle:
    """Combines multiple arbitrary files into a single binary with index header"""
    data = {};
    version = 0;
    calculateHash = False;
    verbose = False;

    def __init__(self, verbose=False, calculateHash=False):
        self.clear();
        self.verbose = verbose;
        self.calculateHash = calculateHash;

    def __len__(self):
        length = 0;
        for mediaType in self.data:
            length += len(self.data[mediaType]);
        return length;

    def clear(self):
        self.version = 0;
        self.data = {};
        for mediaType in getMediaTypeKeys():
            self.data[mediaType] = [];

    def getVersion(self):
        return self.version;

    def setVersion(self, version):
        self.version = version;

    def addFile(self, mediaType, name, filename):
        """Add a file to the bundle"""

        # If mediaType is given as value (string), coerce to key (int)
        if isinstance(mediaType, str):
            mediaType = getMediaTypeKeyFromName(mediaType);

        bf = BundleFile(mediaType, name, filename, self.calculateHash);

        if self.verbose:
            string = "";
            if self.calculateHash:
                string += "{} ".format(bf.getFilehash());
            string += "{} {}".format(bf.getName(), bf.getFilename());
            print string;

        self.data[mediaType].append(bf);

    def load(self, filename):
        """Read contents from binary bundle file"""
        #TODO: Implement from expandBundle

    def getHeaderSize(self):
        """Return number of bytes in header"""
        # 1 uint16_t for version number
        headersize = 2;
        # 1 uint16_t for number of fileids
        headersize += 2;
        # 1 uint16_t for each file
        headersize += len(self) * 2; 
        return headersize;

    def dumps(self):
        """Return string description of bundle contents"""
        result = "";
        offset = self.getHeaderSize();
        fileid = 0;
        for mediaType in self.data:
            mediaTypeName = getMediaTypeNameFromKey(mediaType);
            for entry in self.data[mediaType]:
                result += " #{} 0x{:04x}: {}\n".format(fileid, offset, entry.dumps());
                offset += entry.getFilesize();
                fileid += 1;
        return result;

    def tofile(self, fd):
        """Write contents to binary bundle file"""

        # Write bundle version
        fd.write(pack('H', self.version));

        # Write file count
        fd.write(pack('H', len(self)));

        # Write index
        fileid = 0;
        offset = self.getHeaderSize();
        for mediaType in self.data:
            for entry in self.data[mediaType]:
                fd.write(pack('H', offset));
                offset += entry.getFilesize();
                fileid += 1;

        # Write files
        for mediaType in self.data:
            for entry in self.data[mediaType]:
                entry.tofile(fd);
                offset += entry.getFilesize();
                fileid += 1;

    def toEnumString(self):
        """Return string suitable for inclusion from C/C++"""
        result = "";
        indent = ' '*4;
        fileid = 0;

        result += '/* Generated by bundle.py */\n';
        result += '#define FILE_ID_VERSION {}\n'.format(self.version);
        result += '#define FILE_ID_VERSION_OFFSET   0\n';
        result += '#define FILE_ID_COUNT_OFFSET     2\n';
        result += '#define FILE_ID_INDEX_OFFSET     4\n';
        result += '#define FILE_ID_INDEX_ENTRY_SIZE 2\n';
        result += 'typedef enum {\n';
        for mediaType in self.data:
            mediaTypeName = getMediaTypeNameFromKey(mediaType);
            if len(self.data[mediaType]) > 0:
                result += '{}/* {} */\n'.format(indent, mediaTypeName);
                for entry in self.data[mediaType]:
                    result += '{}{} = {},\n'.format(indent, entry.getName(), fileid);
                    fileid += 1;
                result += '\n';
        result += '{}FILE_ID_COUNT = {}\n'.format(indent, fileid);
        result += '} FileId_t;\n';
        return result;
